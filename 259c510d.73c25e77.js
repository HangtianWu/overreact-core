(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{109:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return g}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,g=u["".concat(i,".").concat(m)]||u[m]||d[m]||o;return n?a.a.createElement(g,c(c({ref:t},l),{},{components:n})):a.a.createElement(g,c({ref:t},l))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var l=2;l<o;l++)i[l]=n[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},81:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return p}));var r=n(3),a=n(7),o=(n(0),n(109)),i={id:"pagination",title:"Pagination"},c={unversionedId:"getting_started/pagination",id:"getting_started/pagination",isDocsHomePage:!1,title:"Pagination",description:"Pagination vs. Fetch",source:"@site/docs/getting_started/pagination.md",slug:"/getting_started/pagination",permalink:"/overreact-core/getting_started/pagination",editUrl:"https://github.com/microsoft/overreact-core/packages/website/edit/master/website/docs/getting_started/pagination.md",version:"current",lastUpdatedBy:"Like Zhu",lastUpdatedAt:1622581971,sidebar:"someSidebar",previous:{title:"Mutating Data",permalink:"/overreact-core/getting_started/mutation"},next:{title:"Handling Errors",permalink:"/overreact-core/getting_started/error"}},s=[{value:"Pagination vs. Fetch",id:"pagination-vs-fetch",children:[]},{value:"Spec Requirement",id:"spec-requirement",children:[]},{value:"Usage",id:"usage",children:[]}],l={toc:s};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"pagination-vs-fetch"},"Pagination vs. Fetch"),Object(o.b)("p",null,"Pagination is used to describe how we request data from server incrementally. In a timeline view of a social media app, we'll always try to show the latest content while incrementally fetching older items, when users scroll down and wanted to see more."),Object(o.b)("p",null,"Generally within overreact, pagination and fetch shares most of the common infrastructures to read data from server. However, pagination components maintain an internal state, where we record the location information of the latest batch requested, and provide users with a handler to request more items of the same batch size."),Object(o.b)("h2",{id:"spec-requirement"},"Spec Requirement"),Object(o.b)("p",null,"Pagination in overreact shares the same specs with Fetch. However, because pagination can only work with a set of data, the pagination specs must have a response contract that is of type ",Object(o.b)("inlineCode",{parentName:"p"},"COLL"),"."),Object(o.b)("h2",{id:"usage"},"Usage"),Object(o.b)("p",null,"To setup pagination for our ",Object(o.b)("inlineCode",{parentName:"p"},"People")," entities, we'll use ",Object(o.b)("inlineCode",{parentName:"p"},"usePagination")," hook:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx",metastring:'title="pagination.js"',title:'"pagination.js"'}),"function Pagination() {\n    const dataRefId = useDataRefId();\n\n    const variables = useMemo(() => ({\n        locator: {\n            descriptor: {},\n        },\n\n        // we'll request 5 items at a time\n        pageSize: 5,\n    }), []);\n\n    const [{\n        data,\n        error,\n    }, {\n        isLoading,\n        hasMore,\n        loadMore,\n    }] = usePagination(dataRefId, variables);\n\n    const loadMorePeople = useCallback(() => {\n        // only load more data when there's more on the server\n        if (hasMore()) {\n            loadMore();\n        }\n    }, [hasMore, loadMore]);\n\n    return (\n        <div>\n            {data && data.map(people => <Text>{people.userName}</Text>)}\n            { !isLoading && \n                <button onClick={loadMorePeople}>Load More</button>\n            }\n        </div>\n    );\n}\n")))}p.isMDXComponent=!0}}]);